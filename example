Middleware,
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { language } from '@/app/[countrycode]/[locale]/login/constants';  // Importing language

// Extract valid country codes and locales from language values
const validCountryCodes = language.map(lang => lang.value);
const validLocales = language.map(lang => lang.value);

export function middleware(request: NextRequest) {
  const url = new URL(request.url);
  const pathSegments = url.pathname.split('/').filter(Boolean);
  const countrycode = pathSegments[0];
  const locale = pathSegments[1];

  // If either countrycode or locale is missing or invalid, redirect to maintenance
  if (!countrycode || !validCountryCodes.includes(countrycode) || !locale || !validLocales.includes(locale)) {
    return NextResponse.redirect(new URL(`/${countrycode || 'us'}/maintenance`, request.url));
  }

  // Proceed if the countrycode and locale are valid
  return NextResponse.next();
}


request
import { getRequestConfig } from 'next-intl/server';
import { headers } from 'next/headers';
import { language } from '@/app/[countrycode]/[locale]/login/constants';

export default getRequestConfig(async () => {
  const availableLocales = language.map(lang => lang.value);  
  const headersList = headers();
  const localeFromHeader = headersList.get('locale') || '';
  
  // No fallback to defaultLocale, just use the locale from the header or throw an error
  if (!availableLocales.includes(localeFromHeader)) {
    throw new Error('Invalid locale');
  }

  try {
    const messages = (await import(`../../messages/${localeFromHeader}.json`)).default;

    return {
      locale: localeFromHeader,
      messages
    };
  } catch (error) {
    console.error('Error loading locale or messages:', error);
    throw new Error('Locale messages not found');
  }
});
